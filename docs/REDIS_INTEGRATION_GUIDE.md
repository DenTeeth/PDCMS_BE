# Redis Integration Guide 2025

## Overview

Redis implementation for Dental Clinic Management System providing:

- **Caching** for frequently accessed data (Appointments, Patients, Services)
- **JWT Token Blacklist** for secure logout
- **Auto-eviction** via EntityListeners

## Architecture

### Components

1. **RedisConfig.java** - Configuration with JSON serialization
2. **RedisService.java** - Cache operations service
3. **EntityListeners** - Auto cache eviction (Appointment, Patient, Service)
4. **TokenBlacklistService.java** - JWT blacklist management
5. **docker-compose.yml** - Redis container setup

### Cache Configuration

| Cache         | TTL      | Use Case        |
| ------------- | -------- | --------------- |
| appointments  | 3 min    | Booking data    |
| patients      | 5 min    | Patient records |
| services      | 30 min   | Service catalog |
| jwt-blacklist | 24 hours | Logout tokens   |

## Docker Compose Setup (Recommended)

### Quick Start

```bash
# Start all services (PostgreSQL + Redis)
docker-compose up -d

# Check containers
docker ps

# View Redis logs
docker logs redis-dental

# Stop services
docker-compose down
```

### docker-compose.yml Configuration

```yaml
version: "3.9"

services:
  postgres:
    image: postgres:13-buster
    container_name: postgres-dental
    ports:
      - "5432:5432"
    volumes:
      - ./pgdata_dental:/var/lib/postgresql/data
    networks:
      - dental-network

  redis:
    image: redis:7-alpine
    container_name: redis-dental
    restart: always
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    command: redis-server --appendonly yes
    networks:
      - dental-network

networks:
  dental-network:
    driver: bridge

volumes:
  pgdata_dental:
  redis-data:
```

### Redis Configuration

```yaml
# application.yaml
spring:
  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:}
  cache:
    type: redis
    redis:
      time-to-live: 600000 # 10 minutes
```

## Railway Deployment

### Prerequisites

1. Railway account: https://railway.app/
2. PostgreSQL plugin installed
3. Redis plugin installed

### Setup Steps

#### 1. Install Redis Plugin

In Railway project dashboard:

- Click "+ New"
- Select "Database" â†’ "Redis"
- Railway automatically injects environment variables:
  - `REDIS_HOST`
  - `REDIS_PORT`
  - `REDIS_PASSWORD`

#### 2. Configure Application

Set environment variable in Railway dashboard:

```
SPRING_PROFILES_ACTIVE=railway
```

This activates `RailwayConfig.java` which:

- Parses `DATABASE_URL` to JDBC format
- Adds SSL requirement for PostgreSQL
- Logs Redis configuration on startup

#### 3. Deploy

```bash
# Commit changes
git add .
git commit -m "feat: Add Redis support"
git push origin main

# Railway auto-deploys from GitHub
```

#### 4. Verify Deployment

Check Railway logs for:

```
===========================================
Railway Redis Configuration
===========================================
Host: redis-production.railway.internal
Port: 6379
Password: SET
===========================================
```

### Railway Environment Variables

Automatically provided by Railway plugins:

| Variable         | Source            | Example                             |
| ---------------- | ----------------- | ----------------------------------- |
| `DATABASE_URL`   | PostgreSQL plugin | `postgres://user:pass@host:5432/db` |
| `REDIS_HOST`     | Redis plugin      | `redis-production.railway.internal` |
| `REDIS_PORT`     | Redis plugin      | `6379`                              |
| `REDIS_PASSWORD` | Redis plugin      | `<auto-generated>`                  |

Optional variables you can set:

| Variable        | Purpose            | Example                     |
| --------------- | ------------------ | --------------------------- |
| `MAIL_USERNAME` | Production email   | `production@clinic.com`     |
| `MAIL_PASSWORD` | Email app password | `<gmail-app-password>`      |
| `FRONTEND_URL`  | CORS configuration | `https://clinic.vercel.app` |

## EntityListener Auto-Eviction

### How It Works

Entities automatically clear cache when modified:

```java
@Entity
@EntityListeners(AppointmentEntityListener.class)
public class Appointment {
    // When saved/updated/deleted, cache is auto-cleared
}
```

### Supported Entities

1. **Appointment** - Clears `appointments::*` cache
2. **Patient** - Clears `patients::*` cache
3. **DentalService** - Clears `services::*` cache

### EntityListener Example

```java
@Component
public class AppointmentEntityListener {
    private static RedisService redisService;

    @PostPersist
    @PostUpdate
    @PostRemove
    public void evictCache(Appointment appointment) {
        redisService.evictAppointmentCache(appointment.getId());
    }
}
```

## RedisService API

### Basic Operations

```java
@Autowired
private RedisService redisService;

// Set value
redisService.set("key", value);
redisService.set("key", value, Duration.ofMinutes(5));

// Get value
Object value = redisService.get("key");

// Delete
redisService.delete("key");
redisService.deleteByPattern("appointments::*");

// Check exists
boolean exists = redisService.exists("key");
```

### Cache Eviction

```java
// Manual cache eviction
redisService.evictAppointmentCache(appointmentId);
redisService.evictPatientCache(patientId);
redisService.evictServiceCache(serviceId);
```

## Redis CLI Commands

### Docker Container Access

```bash
# Connect to Redis in Docker
docker exec -it redis-dental redis-cli

# List all keys
KEYS *

# Check cache entries
KEYS appointments::*
KEYS patients::*
KEYS services::*

# Get value
GET appointments::123

# Check TTL
TTL appointments::123

# Delete key
DEL appointments::123

# Clear all cache (Development only)
FLUSHALL

# Monitor real-time commands
MONITOR
```

### Useful Commands

```bash
# Count keys by pattern
KEYS appointments::* | wc -l

# Check memory usage
INFO memory

# Get Redis stats
INFO stats

# View configuration
CONFIG GET *
```

## Monitoring

### Key Metrics to Track

1. **Cache Hit Rate**

   - Monitor how often cached data is used
   - Low hit rate = cache TTL too short or data too dynamic

2. **Blacklist Size**

   - Number of blacklisted tokens
   - Should decrease as tokens expire

3. **Redis Memory Usage**
   - Railway free tier: 512MB Redis
   - Upgrade if memory usage consistently high

### Spring Boot Actuator

Enable Redis health check in `application.yaml`:

```yaml
management:
  health:
    redis:
      enabled: true
```

Check health endpoint:

```
GET /actuator/health
{
  "status": "UP",
  "components": {
    "redis": {
      "status": "UP",
      "details": {
        "version": "7.0.0"
      }
    }
  }
}
```

## Troubleshooting

### Issue 1: Connection Refused (Local)

**Symptom:**

```
Unable to connect to Redis at localhost:6379
```

**Solution:**

```bash
# Check if Redis is running
docker ps  # For Docker
redis-cli ping  # For native install

# Start Redis
docker start dental-clinic-redis
# OR
sudo service redis-server start
```

### Issue 2: Authentication Failed (Railway)

**Symptom:**

```
ERR AUTH <password> called without any password configured
```

**Solution:**

- Check Railway Redis plugin is installed
- Verify `REDIS_PASSWORD` environment variable exists
- Restart Railway service

### Issue 3: SSL Connection Error (Railway)

**Symptom:**

```
SSL connection error
```

**Solution:**

- Verify `SPRING_PROFILES_ACTIVE=railway` is set
- Check `RailwayConfig.java` adds `?sslmode=require` to PostgreSQL URL
- Railway PostgreSQL requires SSL in production

### Issue 4: Cache Not Working

**Symptom:**

- Method called every time despite `@Cacheable`

**Solution:**

1. Check Redis connection: `GET /actuator/health`
2. Verify `@EnableCaching` in `RedisConfig.java`
3. Check cache name matches configuration
4. Use unique cache keys (avoid collisions)

### Issue 5: Out of Memory (Railway)

**Symptom:**

```
OOM command not allowed when used memory > 'maxmemory'
```

**Solution:**

- Reduce cache TTL values
- Implement cache eviction policy
- Upgrade Railway plan for more Redis memory
- Clear unused caches

## Performance Optimization

### Best Practices

1. **Use Appropriate TTLs**

   - Frequently changing data: 1-5 minutes
   - Semi-static data: 15-30 minutes
   - Static data: 1-24 hours

2. **Implement Cache Keys Strategy**

   ```java
   // Good: Unique keys
   @Cacheable(value = "patients", key = "#id")

   // Bad: Same key for all
   @Cacheable(value = "patients")
   ```

3. **Cache Null Values Carefully**

   ```yaml
   cache:
     redis:
       cache-null-values: false # Avoid caching nulls
   ```

4. **Monitor Cache Size**
   - Set maxmemory limits
   - Implement eviction policies (LRU recommended)

### Redis Configuration Tuning

For high-traffic production:

```yaml
spring:
  data:
    redis:
      lettuce:
        pool:
          max-active: 16 # Increase for more connections
          max-idle: 16
          min-idle: 4
          max-wait: 1000ms
        shutdown-timeout: 100ms
      timeout: 60000 # Connection timeout
```

## Migration Notes

### From In-Memory to Redis

**Before (In-Memory):**

```java
private final ConcurrentHashMap<String, Long> blacklistedTokens;
```

**After (Redis):**

```java
private final RedisTemplate<String, Object> redisTemplate;
```

### Breaking Changes

None. The service interface remains the same:

```java
void blacklistToken(String token);
boolean isTokenBlacklisted(String token);
```

### Backward Compatibility

New methods added:

```java
void blacklistToken(String token, String reason);
String getBlacklistReason(String token);
void blacklistAllUserTokens(String username);
```

## Security Considerations

### Redis Password

**Local Development:**

- No password required (localhost only)

**Production (Railway):**

- Auto-generated strong password
- Injected via environment variable
- Never commit passwords to Git

### Network Security

**Local:**

- Redis binds to `127.0.0.1` only
- Not accessible from network

**Railway:**

- Redis on internal network (`.railway.internal`)
- Not exposed to public internet
- Accessible only by services in same Railway project

### Data Encryption

**In Transit:**

- Railway uses internal TLS for Redis connections
- PostgreSQL requires SSL (`sslmode=require`)

**At Rest:**

- Railway encrypts data at rest
- Redis data is temporary (TTL-based)

## Cost Estimation

### Railway Free Tier

- **PostgreSQL:** 512MB storage, 1GB RAM
- **Redis:** 512MB RAM
- **Web Service:** $5/month (500 hours)
- **Bandwidth:** 100GB/month

### Scaling Costs

| Plan  | PostgreSQL    | Redis | Cost   |
| ----- | ------------- | ----- | ------ |
| Hobby | 8GB storage   | 512MB | $5/mo  |
| Pro   | 100GB storage | 1GB   | $20/mo |
| Team  | 500GB storage | 4GB   | $50/mo |

### Cost Optimization Tips

1. Use appropriate cache TTLs (reduce database queries)
2. Implement pagination (reduce data transfer)
3. Monitor usage with Railway dashboard
4. Clean up unused resources

## Further Reading

### Official Documentation

- [Spring Data Redis](https://spring.io/projects/spring-data-redis)
- [Spring Cache Abstraction](https://docs.spring.io/spring-framework/reference/integration/cache.html)
- [Railway Documentation](https://docs.railway.app/)
- [Redis Documentation](https://redis.io/docs/)

### Related Files

- `src/main/java/com/dental/clinic/management/config/RedisConfig.java`
- `src/main/java/com/dental/clinic/management/config/RailwayConfig.java`
- `src/main/java/com/dental/clinic/management/authentication/service/TokenBlacklistService.java`
- `src/main/resources/application.yaml`
- `railway.toml`

## Support

For issues or questions:

1. Check this documentation
2. Review Railway logs
3. Test Redis connection with `redis-cli`
4. Contact DevOps team

---

**Last Updated:** 2025-12-11
**Version:** 2.0
**Stack:** Redis 7 Alpine + Spring Data Redis + Docker Compose
